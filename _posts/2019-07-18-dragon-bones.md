---
layout: post
title: "Dragon Bones"
date: 2019-07-18 01:11:11 -0700
tag: 
- software_design
- metaphors
- dragon_building
- post
comments: true
---

## Alternatively: "what it feels like to be a first-time systems architect with no guidance and looming deadlines"

I ought to start with a disclaimer: I am *not* a systems architect. I have no background in systems architecture. I have questionable background in proper software engineering, if we’re being completely honest here. I am fundamentally a researcher who happens to have found himself, entirely due to his own actions, in the temporary role of a systems architect. Not only that, but the software that I have volunteered to re-design from the ground up is a piece of infrastructure that is critical to multiple functions of the hedge fund that I work for, and which at runtime involves processing of huge volumes of data and asynchronous execution of complex tasks. Some might call me a fool, or a masochist. I fear they are correct on both counts. 

That said, I have decided to do what many fools do when faced with self-inflicted adversity: share it with strangers on the internet! My sideways tumble into the world of software design over the last month or so has been an intriguing one, and I thought that at a minimum others might take something useful away from my suffering (or at least find humor in pointing out my obvious blunders as I charge headfirst into them). Unfortunately, as I do happen to work for a hedge fund, I’ll be required to keep certain design decisions and many implementation details vague. I hope that what I am able to discuss, especially considering design philosophy and my personal experiences, remains interesting. 

At the time of writing I’ve just about completed a critical step towards the realization of this piece of software: development of a written plan. This seems like a good time to confess that I have a barely-functional knowledge of agile development derived primarily from sarcastic memes, but even that is sufficient for me to know that I’ve already took a u-turn from the standard agile framework and headed straight into waterfall land. In my defense, the software I’m building has some narrow, well-defined requirements that are a bit different than one might find when building something like a modern web or desktop application:
- All internal and external APIs involved are fully visible and stable (the operating environment is known and highly unlikely to change)
- The program can be divided into essentially independent components, each of which has a strict interface and well-defined behavioral model
- An existing piece of software implementing most of the functionality required is available (the new project essentially involves replacing this software, as it is extremely old legacy code and maintaining it has become too difficult)
- The program has strict speed requirements and cannot ship if these requirements are not met
- The program must be extraordinarily error tolerant, with comprehensive error capture, reporting, and handling facilities
As such, I feel fairly confident that a waterfallish formal-methods type approach to the design of the system is appropriate. Any possible changes to the operating environment or system requirements are highly predictable, and as a design constraint all possible behavioral modes and error states must be identified and accounted for. This, of course, does not mean that designing the system was easy. 

Over the last week, when not slaving over this system architecture proposal or doing other hedge fund research things, I’ve been hallucinating some metaphors for this stage in the architecture process. At the very beginning, it felt awesome. Right in front of me was the opportunity to gain some leadership experience and improve my life as a researcher by taking initiative and orchestrating the rewrite of an aging, unmaintainable suite of core tools that everyone knew needed to go. I was going to go out, put to sleep this tumor-ridden workhorse of a system, and come back riding on a goddamned dragon. The excitement of deciding what I wanted our dragon to look like was a bit infectious, and soon there were conversations among the research team around the clock about how much this awesome new project was going to improve our capabilities as a group. By the time we had laid out our wish list it was also going to give everyone a daily foot massage and make their morning coffee. 

Unfortunately, it turns out that talking about what you want a dragon to be able to do is not the same as knowing how to make a dragon. Even worse, none of us had actually seen a dragon before, let alone built our own. One might argue that the system destined to be replaced by the new project (the decrepit workhorse) might serve as a good dragon template, but part of the impetus for building the dragon was enabling behaviors that a horse simply can’t do, like flying and breathing fire. On the plus side, we had a strict, formal description of said behaviors. On the minus side, they started to seem a little terrifying once I sat down to try to fill in the outline left by our system requirements.

Ultimately, designing this architecture has been about sketching dragon bones. First and foremost, it needs to support all of the required features: you can’t expect a dragon to fly without wing bones. It also has to fit inside the boundaries set by the design requirements: if your dragon is going to enter and exit through a human-sized door, don’t give it a 20-foot-tall skeleton. By approaching each requirement systematically, you can start to get an idea of what shape the head needs to be and how many legs it needs to have. You may also run into contradictions that kick you back into the “what can the dragon do” phase, as clearly a dragon can’t have 2 tails and zero heads. Eventually you do your best to find some research on dragon anatomy and then start drawing one bone at a time, all while trying to imagine what it’ll look like with nerves and muscles and skin on top. 

At least that’s how it works if you have a well-defined and static set of requirements. In theory, anyways. I fully expect that by the end of this process we’ll also end up being fairly experienced dragon surgeons and maybe even dragon geneticists, especially considering that actually creating the bones is a bit different than drawing then in a notebook. For now we have a plan for how to build a skeleton, and it seems like it has a decent shot at flying someday. This is good, because our deadline is, um, not exactly very far away. Before any of that, bones on paper need to turn into bones in the real world. 
I have another confession to make: I don’t actually plan on sharing any system requirements or designs just yet. Partially because I’m not sure how much detail is appropriate, but mostly because there are still other hands these need to pass through for approval and a handful of wrinkly segments that must be ironed flat. Truthfully, these blog posts are more about my experience of designing the system than about how one might replicate my efforts. I fully intend to paint a proper picture of what is going on behind the scenes and describe in detail the problems I encounter, but without saying anything that might get me fired and thus render the effort pointless. 

Given the narrow scope and mission-critical nature of the project, we’ll actually be taking a step back from my dragon-skeleton-plan before we use any Python or C to construct real dragon bones. We need to make sure that the final dragon meets spec perfectly, so we’ll spend the next sprint building a set of tests that will allow us to verify that our dragon does what we planned it to do. The next entry in this series, provided that I am stymied by neither my foolishness nor my masochism, will detail what the dragon is supposed to look like on the outside, how we plan to test our dragon, and a brief tour of the skeleton I’ve dreamed up to support the beastie. Feel free to come along for the ride. I recommend you bring a couple pots of coffee and perhaps some aspirin, if my experience so far has been at all representative. 
